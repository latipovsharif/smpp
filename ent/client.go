// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"log"

	"smpp/ent/migrate"

	"smpp/ent/messages"
	"smpp/ent/price"
	"smpp/ent/provide"
	"smpp/ent/rate"
	"smpp/ent/rateprice"
	"smpp/ent/user"
	"smpp/ent/usermonthmessage"

	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/google/uuid"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Messages is the client for interacting with the Messages builders.
	Messages *MessagesClient
	// Price is the client for interacting with the Price builders.
	Price *PriceClient
	// Provide is the client for interacting with the Provide builders.
	Provide *ProvideClient
	// Rate is the client for interacting with the Rate builders.
	Rate *RateClient
	// RatePrice is the client for interacting with the RatePrice builders.
	RatePrice *RatePriceClient
	// User is the client for interacting with the User builders.
	User *UserClient
	// UserMonthMessage is the client for interacting with the UserMonthMessage builders.
	UserMonthMessage *UserMonthMessageClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	cfg := config{log: log.Println, hooks: &hooks{}}
	cfg.options(opts...)
	client := &Client{config: cfg}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Messages = NewMessagesClient(c.config)
	c.Price = NewPriceClient(c.config)
	c.Provide = NewProvideClient(c.config)
	c.Rate = NewRateClient(c.config)
	c.RatePrice = NewRatePriceClient(c.config)
	c.User = NewUserClient(c.config)
	c.UserMonthMessage = NewUserMonthMessageClient(c.config)
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, fmt.Errorf("ent: cannot start a transaction within a transaction")
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:              ctx,
		config:           cfg,
		Messages:         NewMessagesClient(cfg),
		Price:            NewPriceClient(cfg),
		Provide:          NewProvideClient(cfg),
		Rate:             NewRateClient(cfg),
		RatePrice:        NewRatePriceClient(cfg),
		User:             NewUserClient(cfg),
		UserMonthMessage: NewUserMonthMessageClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, fmt.Errorf("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		config:           cfg,
		Messages:         NewMessagesClient(cfg),
		Price:            NewPriceClient(cfg),
		Provide:          NewProvideClient(cfg),
		Rate:             NewRateClient(cfg),
		RatePrice:        NewRatePriceClient(cfg),
		User:             NewUserClient(cfg),
		UserMonthMessage: NewUserMonthMessageClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Messages.
//		Query().
//		Count(ctx)
//
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	c.Messages.Use(hooks...)
	c.Price.Use(hooks...)
	c.Provide.Use(hooks...)
	c.Rate.Use(hooks...)
	c.RatePrice.Use(hooks...)
	c.User.Use(hooks...)
	c.UserMonthMessage.Use(hooks...)
}

// MessagesClient is a client for the Messages schema.
type MessagesClient struct {
	config
}

// NewMessagesClient returns a client for the Messages from the given config.
func NewMessagesClient(c config) *MessagesClient {
	return &MessagesClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `messages.Hooks(f(g(h())))`.
func (c *MessagesClient) Use(hooks ...Hook) {
	c.hooks.Messages = append(c.hooks.Messages, hooks...)
}

// Create returns a create builder for Messages.
func (c *MessagesClient) Create() *MessagesCreate {
	mutation := newMessagesMutation(c.config, OpCreate)
	return &MessagesCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Messages entities.
func (c *MessagesClient) CreateBulk(builders ...*MessagesCreate) *MessagesCreateBulk {
	return &MessagesCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Messages.
func (c *MessagesClient) Update() *MessagesUpdate {
	mutation := newMessagesMutation(c.config, OpUpdate)
	return &MessagesUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MessagesClient) UpdateOne(m *Messages) *MessagesUpdateOne {
	mutation := newMessagesMutation(c.config, OpUpdateOne, withMessages(m))
	return &MessagesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MessagesClient) UpdateOneID(id uuid.UUID) *MessagesUpdateOne {
	mutation := newMessagesMutation(c.config, OpUpdateOne, withMessagesID(id))
	return &MessagesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Messages.
func (c *MessagesClient) Delete() *MessagesDelete {
	mutation := newMessagesMutation(c.config, OpDelete)
	return &MessagesDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *MessagesClient) DeleteOne(m *Messages) *MessagesDeleteOne {
	return c.DeleteOneID(m.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *MessagesClient) DeleteOneID(id uuid.UUID) *MessagesDeleteOne {
	builder := c.Delete().Where(messages.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MessagesDeleteOne{builder}
}

// Query returns a query builder for Messages.
func (c *MessagesClient) Query() *MessagesQuery {
	return &MessagesQuery{config: c.config}
}

// Get returns a Messages entity by its id.
func (c *MessagesClient) Get(ctx context.Context, id uuid.UUID) (*Messages, error) {
	return c.Query().Where(messages.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MessagesClient) GetX(ctx context.Context, id uuid.UUID) *Messages {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUserID queries the user_id edge of a Messages.
func (c *MessagesClient) QueryUserID(m *Messages) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(messages.Table, messages.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, messages.UserIDTable, messages.UserIDColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProviderID queries the provider_id edge of a Messages.
func (c *MessagesClient) QueryProviderID(m *Messages) *ProvideQuery {
	query := &ProvideQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(messages.Table, messages.FieldID, id),
			sqlgraph.To(provide.Table, provide.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, messages.ProviderIDTable, messages.ProviderIDColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MessagesClient) Hooks() []Hook {
	return c.hooks.Messages
}

// PriceClient is a client for the Price schema.
type PriceClient struct {
	config
}

// NewPriceClient returns a client for the Price from the given config.
func NewPriceClient(c config) *PriceClient {
	return &PriceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `price.Hooks(f(g(h())))`.
func (c *PriceClient) Use(hooks ...Hook) {
	c.hooks.Price = append(c.hooks.Price, hooks...)
}

// Create returns a create builder for Price.
func (c *PriceClient) Create() *PriceCreate {
	mutation := newPriceMutation(c.config, OpCreate)
	return &PriceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Price entities.
func (c *PriceClient) CreateBulk(builders ...*PriceCreate) *PriceCreateBulk {
	return &PriceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Price.
func (c *PriceClient) Update() *PriceUpdate {
	mutation := newPriceMutation(c.config, OpUpdate)
	return &PriceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PriceClient) UpdateOne(pr *Price) *PriceUpdateOne {
	mutation := newPriceMutation(c.config, OpUpdateOne, withPrice(pr))
	return &PriceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PriceClient) UpdateOneID(id uuid.UUID) *PriceUpdateOne {
	mutation := newPriceMutation(c.config, OpUpdateOne, withPriceID(id))
	return &PriceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Price.
func (c *PriceClient) Delete() *PriceDelete {
	mutation := newPriceMutation(c.config, OpDelete)
	return &PriceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *PriceClient) DeleteOne(pr *Price) *PriceDeleteOne {
	return c.DeleteOneID(pr.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *PriceClient) DeleteOneID(id uuid.UUID) *PriceDeleteOne {
	builder := c.Delete().Where(price.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PriceDeleteOne{builder}
}

// Query returns a query builder for Price.
func (c *PriceClient) Query() *PriceQuery {
	return &PriceQuery{config: c.config}
}

// Get returns a Price entity by its id.
func (c *PriceClient) Get(ctx context.Context, id uuid.UUID) (*Price, error) {
	return c.Query().Where(price.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PriceClient) GetX(ctx context.Context, id uuid.UUID) *Price {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPriceID queries the price_id edge of a Price.
func (c *PriceClient) QueryPriceID(pr *Price) *RatePriceQuery {
	query := &RatePriceQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(price.Table, price.FieldID, id),
			sqlgraph.To(rateprice.Table, rateprice.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, price.PriceIDTable, price.PriceIDColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PriceClient) Hooks() []Hook {
	return c.hooks.Price
}

// ProvideClient is a client for the Provide schema.
type ProvideClient struct {
	config
}

// NewProvideClient returns a client for the Provide from the given config.
func NewProvideClient(c config) *ProvideClient {
	return &ProvideClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `provide.Hooks(f(g(h())))`.
func (c *ProvideClient) Use(hooks ...Hook) {
	c.hooks.Provide = append(c.hooks.Provide, hooks...)
}

// Create returns a create builder for Provide.
func (c *ProvideClient) Create() *ProvideCreate {
	mutation := newProvideMutation(c.config, OpCreate)
	return &ProvideCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Provide entities.
func (c *ProvideClient) CreateBulk(builders ...*ProvideCreate) *ProvideCreateBulk {
	return &ProvideCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Provide.
func (c *ProvideClient) Update() *ProvideUpdate {
	mutation := newProvideMutation(c.config, OpUpdate)
	return &ProvideUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProvideClient) UpdateOne(pr *Provide) *ProvideUpdateOne {
	mutation := newProvideMutation(c.config, OpUpdateOne, withProvide(pr))
	return &ProvideUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProvideClient) UpdateOneID(id uuid.UUID) *ProvideUpdateOne {
	mutation := newProvideMutation(c.config, OpUpdateOne, withProvideID(id))
	return &ProvideUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Provide.
func (c *ProvideClient) Delete() *ProvideDelete {
	mutation := newProvideMutation(c.config, OpDelete)
	return &ProvideDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *ProvideClient) DeleteOne(pr *Provide) *ProvideDeleteOne {
	return c.DeleteOneID(pr.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *ProvideClient) DeleteOneID(id uuid.UUID) *ProvideDeleteOne {
	builder := c.Delete().Where(provide.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProvideDeleteOne{builder}
}

// Query returns a query builder for Provide.
func (c *ProvideClient) Query() *ProvideQuery {
	return &ProvideQuery{config: c.config}
}

// Get returns a Provide entity by its id.
func (c *ProvideClient) Get(ctx context.Context, id uuid.UUID) (*Provide, error) {
	return c.Query().Where(provide.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProvideClient) GetX(ctx context.Context, id uuid.UUID) *Provide {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProviderID queries the provider_id edge of a Provide.
func (c *ProvideClient) QueryProviderID(pr *Provide) *UserMonthMessageQuery {
	query := &UserMonthMessageQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(provide.Table, provide.FieldID, id),
			sqlgraph.To(usermonthmessage.Table, usermonthmessage.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, provide.ProviderIDTable, provide.ProviderIDColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMessages queries the messages edge of a Provide.
func (c *ProvideClient) QueryMessages(pr *Provide) *MessagesQuery {
	query := &MessagesQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(provide.Table, provide.FieldID, id),
			sqlgraph.To(messages.Table, messages.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, provide.MessagesTable, provide.MessagesColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProvideClient) Hooks() []Hook {
	return c.hooks.Provide
}

// RateClient is a client for the Rate schema.
type RateClient struct {
	config
}

// NewRateClient returns a client for the Rate from the given config.
func NewRateClient(c config) *RateClient {
	return &RateClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `rate.Hooks(f(g(h())))`.
func (c *RateClient) Use(hooks ...Hook) {
	c.hooks.Rate = append(c.hooks.Rate, hooks...)
}

// Create returns a create builder for Rate.
func (c *RateClient) Create() *RateCreate {
	mutation := newRateMutation(c.config, OpCreate)
	return &RateCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Rate entities.
func (c *RateClient) CreateBulk(builders ...*RateCreate) *RateCreateBulk {
	return &RateCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Rate.
func (c *RateClient) Update() *RateUpdate {
	mutation := newRateMutation(c.config, OpUpdate)
	return &RateUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RateClient) UpdateOne(r *Rate) *RateUpdateOne {
	mutation := newRateMutation(c.config, OpUpdateOne, withRate(r))
	return &RateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RateClient) UpdateOneID(id uuid.UUID) *RateUpdateOne {
	mutation := newRateMutation(c.config, OpUpdateOne, withRateID(id))
	return &RateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Rate.
func (c *RateClient) Delete() *RateDelete {
	mutation := newRateMutation(c.config, OpDelete)
	return &RateDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *RateClient) DeleteOne(r *Rate) *RateDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *RateClient) DeleteOneID(id uuid.UUID) *RateDeleteOne {
	builder := c.Delete().Where(rate.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RateDeleteOne{builder}
}

// Query returns a query builder for Rate.
func (c *RateClient) Query() *RateQuery {
	return &RateQuery{config: c.config}
}

// Get returns a Rate entity by its id.
func (c *RateClient) Get(ctx context.Context, id uuid.UUID) (*Rate, error) {
	return c.Query().Where(rate.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RateClient) GetX(ctx context.Context, id uuid.UUID) *Rate {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRateID queries the rate_id edge of a Rate.
func (c *RateClient) QueryRateID(r *Rate) *RatePriceQuery {
	query := &RatePriceQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(rate.Table, rate.FieldID, id),
			sqlgraph.To(rateprice.Table, rateprice.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, rate.RateIDTable, rate.RateIDColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RateClient) Hooks() []Hook {
	return c.hooks.Rate
}

// RatePriceClient is a client for the RatePrice schema.
type RatePriceClient struct {
	config
}

// NewRatePriceClient returns a client for the RatePrice from the given config.
func NewRatePriceClient(c config) *RatePriceClient {
	return &RatePriceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `rateprice.Hooks(f(g(h())))`.
func (c *RatePriceClient) Use(hooks ...Hook) {
	c.hooks.RatePrice = append(c.hooks.RatePrice, hooks...)
}

// Create returns a create builder for RatePrice.
func (c *RatePriceClient) Create() *RatePriceCreate {
	mutation := newRatePriceMutation(c.config, OpCreate)
	return &RatePriceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of RatePrice entities.
func (c *RatePriceClient) CreateBulk(builders ...*RatePriceCreate) *RatePriceCreateBulk {
	return &RatePriceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for RatePrice.
func (c *RatePriceClient) Update() *RatePriceUpdate {
	mutation := newRatePriceMutation(c.config, OpUpdate)
	return &RatePriceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RatePriceClient) UpdateOne(rp *RatePrice) *RatePriceUpdateOne {
	mutation := newRatePriceMutation(c.config, OpUpdateOne, withRatePrice(rp))
	return &RatePriceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RatePriceClient) UpdateOneID(id uuid.UUID) *RatePriceUpdateOne {
	mutation := newRatePriceMutation(c.config, OpUpdateOne, withRatePriceID(id))
	return &RatePriceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for RatePrice.
func (c *RatePriceClient) Delete() *RatePriceDelete {
	mutation := newRatePriceMutation(c.config, OpDelete)
	return &RatePriceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *RatePriceClient) DeleteOne(rp *RatePrice) *RatePriceDeleteOne {
	return c.DeleteOneID(rp.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *RatePriceClient) DeleteOneID(id uuid.UUID) *RatePriceDeleteOne {
	builder := c.Delete().Where(rateprice.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RatePriceDeleteOne{builder}
}

// Query returns a query builder for RatePrice.
func (c *RatePriceClient) Query() *RatePriceQuery {
	return &RatePriceQuery{config: c.config}
}

// Get returns a RatePrice entity by its id.
func (c *RatePriceClient) Get(ctx context.Context, id uuid.UUID) (*RatePrice, error) {
	return c.Query().Where(rateprice.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RatePriceClient) GetX(ctx context.Context, id uuid.UUID) *RatePrice {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryIDRate queries the id_rate edge of a RatePrice.
func (c *RatePriceClient) QueryIDRate(rp *RatePrice) *RateQuery {
	query := &RateQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := rp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(rateprice.Table, rateprice.FieldID, id),
			sqlgraph.To(rate.Table, rate.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, rateprice.IDRateTable, rateprice.IDRateColumn),
		)
		fromV = sqlgraph.Neighbors(rp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIDPrice queries the id_price edge of a RatePrice.
func (c *RatePriceClient) QueryIDPrice(rp *RatePrice) *PriceQuery {
	query := &PriceQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := rp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(rateprice.Table, rateprice.FieldID, id),
			sqlgraph.To(price.Table, price.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, rateprice.IDPriceTable, rateprice.IDPriceColumn),
		)
		fromV = sqlgraph.Neighbors(rp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a RatePrice.
func (c *RatePriceClient) QueryUser(rp *RatePrice) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := rp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(rateprice.Table, rateprice.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, rateprice.UserTable, rateprice.UserColumn),
		)
		fromV = sqlgraph.Neighbors(rp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RatePriceClient) Hooks() []Hook {
	return c.hooks.RatePrice
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Create returns a create builder for User.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id uuid.UUID) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *UserClient) DeleteOneID(id uuid.UUID) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{config: c.config}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id uuid.UUID) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id uuid.UUID) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUserMessages queries the user_messages edge of a User.
func (c *UserClient) QueryUserMessages(u *User) *UserMonthMessageQuery {
	query := &UserMonthMessageQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(usermonthmessage.Table, usermonthmessage.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.UserMessagesTable, user.UserMessagesColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMessages queries the messages edge of a User.
func (c *UserClient) QueryMessages(u *User) *MessagesQuery {
	query := &MessagesQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(messages.Table, messages.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.MessagesTable, user.MessagesColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRateID queries the rate_id edge of a User.
func (c *UserClient) QueryRateID(u *User) *RatePriceQuery {
	query := &RatePriceQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(rateprice.Table, rateprice.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, user.RateIDTable, user.RateIDColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}

// UserMonthMessageClient is a client for the UserMonthMessage schema.
type UserMonthMessageClient struct {
	config
}

// NewUserMonthMessageClient returns a client for the UserMonthMessage from the given config.
func NewUserMonthMessageClient(c config) *UserMonthMessageClient {
	return &UserMonthMessageClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `usermonthmessage.Hooks(f(g(h())))`.
func (c *UserMonthMessageClient) Use(hooks ...Hook) {
	c.hooks.UserMonthMessage = append(c.hooks.UserMonthMessage, hooks...)
}

// Create returns a create builder for UserMonthMessage.
func (c *UserMonthMessageClient) Create() *UserMonthMessageCreate {
	mutation := newUserMonthMessageMutation(c.config, OpCreate)
	return &UserMonthMessageCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserMonthMessage entities.
func (c *UserMonthMessageClient) CreateBulk(builders ...*UserMonthMessageCreate) *UserMonthMessageCreateBulk {
	return &UserMonthMessageCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserMonthMessage.
func (c *UserMonthMessageClient) Update() *UserMonthMessageUpdate {
	mutation := newUserMonthMessageMutation(c.config, OpUpdate)
	return &UserMonthMessageUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserMonthMessageClient) UpdateOne(umm *UserMonthMessage) *UserMonthMessageUpdateOne {
	mutation := newUserMonthMessageMutation(c.config, OpUpdateOne, withUserMonthMessage(umm))
	return &UserMonthMessageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserMonthMessageClient) UpdateOneID(id uuid.UUID) *UserMonthMessageUpdateOne {
	mutation := newUserMonthMessageMutation(c.config, OpUpdateOne, withUserMonthMessageID(id))
	return &UserMonthMessageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserMonthMessage.
func (c *UserMonthMessageClient) Delete() *UserMonthMessageDelete {
	mutation := newUserMonthMessageMutation(c.config, OpDelete)
	return &UserMonthMessageDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *UserMonthMessageClient) DeleteOne(umm *UserMonthMessage) *UserMonthMessageDeleteOne {
	return c.DeleteOneID(umm.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *UserMonthMessageClient) DeleteOneID(id uuid.UUID) *UserMonthMessageDeleteOne {
	builder := c.Delete().Where(usermonthmessage.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserMonthMessageDeleteOne{builder}
}

// Query returns a query builder for UserMonthMessage.
func (c *UserMonthMessageClient) Query() *UserMonthMessageQuery {
	return &UserMonthMessageQuery{config: c.config}
}

// Get returns a UserMonthMessage entity by its id.
func (c *UserMonthMessageClient) Get(ctx context.Context, id uuid.UUID) (*UserMonthMessage, error) {
	return c.Query().Where(usermonthmessage.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserMonthMessageClient) GetX(ctx context.Context, id uuid.UUID) *UserMonthMessage {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProviderID queries the provider_id edge of a UserMonthMessage.
func (c *UserMonthMessageClient) QueryProviderID(umm *UserMonthMessage) *ProvideQuery {
	query := &ProvideQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := umm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(usermonthmessage.Table, usermonthmessage.FieldID, id),
			sqlgraph.To(provide.Table, provide.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, usermonthmessage.ProviderIDTable, usermonthmessage.ProviderIDColumn),
		)
		fromV = sqlgraph.Neighbors(umm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUserID queries the user_id edge of a UserMonthMessage.
func (c *UserMonthMessageClient) QueryUserID(umm *UserMonthMessage) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := umm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(usermonthmessage.Table, usermonthmessage.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, usermonthmessage.UserIDTable, usermonthmessage.UserIDColumn),
		)
		fromV = sqlgraph.Neighbors(umm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserMonthMessageClient) Hooks() []Hook {
	return c.hooks.UserMonthMessage
}
